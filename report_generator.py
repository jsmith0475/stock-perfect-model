"""
Report Generator Module.

Uses AWS Bedrock (Claude Sonnet) to generate comprehensive trading reports
combining quantitative signals with natural language explanations.
"""

import numpy as np
import pandas as pd
from datetime import datetime
from typing import Optional
from dataclasses import dataclass

from bedrock_client import BedrockClient, ClaudeModel


@dataclass
class TradingReport:
    """Structured trading report."""
    title: str
    executive_summary: str
    market_regime_analysis: str
    top_opportunities: str
    risk_warnings: str
    recommended_positions: str
    timestamp: datetime
    
    def to_markdown(self) -> str:
        """Convert report to markdown format."""
        return f"""# {self.title}
*Generated: {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}*

## Executive Summary
{self.executive_summary}

## Market Regime Analysis
{self.market_regime_analysis}

## Top Opportunities
{self.top_opportunities}

## Risk Warnings
{self.risk_warnings}

## Recommended Positions
{self.recommended_positions}

---
*This report was generated by the Stock Perfect Model using algebraic topology and LLM analysis.*
"""

    def to_html(self) -> str:
        """Convert report to HTML format."""
        import html
        
        def md_to_html(text: str) -> str:
            """Simple markdown to HTML conversion."""
            lines = text.split('\n')
            result = []
            in_list = False
            
            for line in lines:
                line = html.escape(line)
                if line.startswith('- '):
                    if not in_list:
                        result.append('<ul>')
                        in_list = True
                    result.append(f'<li>{line[2:]}</li>')
                else:
                    if in_list:
                        result.append('</ul>')
                        in_list = False
                    if line.strip():
                        result.append(f'<p>{line}</p>')
            
            if in_list:
                result.append('</ul>')
            
            return '\n'.join(result)
        
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>{html.escape(self.title)}</title>
    <style>
        body {{ font-family: 'Segoe UI', Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #0d1117; color: #c9d1d9; }}
        h1 {{ color: #58a6ff; border-bottom: 2px solid #30363d; padding-bottom: 10px; }}
        h2 {{ color: #79c0ff; margin-top: 30px; }}
        .timestamp {{ color: #8b949e; font-style: italic; }}
        .warning {{ background: #3d1f1f; border-left: 4px solid #f85149; padding: 10px 15px; margin: 10px 0; }}
        .opportunity {{ background: #1f3d1f; border-left: 4px solid #3fb950; padding: 10px 15px; margin: 10px 0; }}
        ul {{ padding-left: 20px; }}
        li {{ margin: 5px 0; }}
        hr {{ border: none; border-top: 1px solid #30363d; margin: 30px 0; }}
        .footer {{ color: #8b949e; font-size: 0.9em; }}
    </style>
</head>
<body>
    <h1>{html.escape(self.title)}</h1>
    <p class="timestamp">Generated: {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</p>
    
    <h2>Executive Summary</h2>
    {md_to_html(self.executive_summary)}
    
    <h2>Market Regime Analysis</h2>
    {md_to_html(self.market_regime_analysis)}
    
    <h2>Top Opportunities</h2>
    <div class="opportunity">
    {md_to_html(self.top_opportunities)}
    </div>
    
    <h2>Risk Warnings</h2>
    <div class="warning">
    {md_to_html(self.risk_warnings)}
    </div>
    
    <h2>Recommended Positions</h2>
    {md_to_html(self.recommended_positions)}
    
    <hr>
    <p class="footer">This report was generated by the Stock Perfect Model using algebraic topology and LLM analysis.</p>
</body>
</html>
"""


class ReportGenerator:
    """
    Generates comprehensive trading reports using Claude Sonnet.
    
    Combines quantitative signals with natural language explanations.
    """
    
    SYSTEM_PROMPT = """You are a senior quantitative portfolio manager writing daily trading reports.

Your reports should be:
1. Concise but comprehensive
2. Actionable with specific recommendations
3. Risk-aware with clear warnings
4. Data-driven, referencing the provided metrics

Use professional financial language. Focus on what matters for trading decisions.
Format with bullet points and clear sections. Be specific about position sizes (% of portfolio)."""

    def __init__(self):
        self.client = BedrockClient()
        
    def generate_daily_report(
        self,
        # Topology features
        h1_total_persistence: float,
        h1_max_persistence: float,
        h1_feature_count: int,
        regime_type: str,
        risk_level: str,
        # Residuals (mispricings)
        top_residuals: pd.DataFrame,  # columns: ticker, residual, sector
        # Sentiment (optional)
        sentiment_data: Optional[pd.DataFrame] = None,  # columns: ticker, sentiment_score, summary
        # Portfolio context
        current_positions: Optional[dict] = None,
        portfolio_beta: Optional[float] = None,
    ) -> TradingReport:
        """
        Generate a comprehensive daily trading report.
        
        Args:
            h1_total_persistence: Total H1 persistence (market complexity)
            h1_max_persistence: Max H1 persistence (dominant structure strength)
            h1_feature_count: Number of H1 features
            regime_type: Detected market regime
            risk_level: Current risk level
            top_residuals: DataFrame of top residual stocks
            sentiment_data: Optional sentiment analysis results
            current_positions: Optional dict of current holdings
            portfolio_beta: Optional current portfolio beta
            
        Returns:
            TradingReport with all sections
        """
        # Format data for the prompt
        residuals_text = top_residuals.to_string() if not top_residuals.empty else "No significant residuals"
        
        sentiment_text = ""
        if sentiment_data is not None and not sentiment_data.empty:
            sentiment_text = f"\n\nSENTIMENT DATA:\n{sentiment_data.to_string()}"
            
        positions_text = ""
        if current_positions:
            positions_text = f"\n\nCURRENT POSITIONS: {current_positions}"
            
        beta_text = f"\nPortfolio Beta: {portfolio_beta:.2f}" if portfolio_beta else ""
        
        prompt = f"""Generate a comprehensive daily trading report based on the following data:

TOPOLOGY METRICS (Persistent Homology):
- H1 Total Persistence: {h1_total_persistence:.4f}
- H1 Max Persistence: {h1_max_persistence:.4f}
- H1 Feature Count: {h1_feature_count}
- Detected Regime: {regime_type}
- Risk Level: {risk_level}

TOP RESIDUAL STOCKS (potential mispricings, sorted by absolute residual):
{residuals_text}
{sentiment_text}
{positions_text}
{beta_text}

Generate a JSON response with these sections:
{{
    "executive_summary": "<3-4 sentences summarizing today's key findings and overall recommendation>",
    "market_regime_analysis": "<2-3 paragraphs explaining the current market regime based on topology, what it means, and historical context>",
    "top_opportunities": "<bullet list of top 3-5 trading opportunities based on residuals and sentiment, with specific entry points and sizing>",
    "risk_warnings": "<bullet list of key risks and what to watch for>",
    "recommended_positions": "<specific position recommendations with sizing (% of portfolio), entry, and stop-loss levels>"
}}"""

        try:
            result = self.client.invoke_for_json(
                prompt=prompt,
                model=ClaudeModel.SONNET,
                system_prompt=self.SYSTEM_PROMPT,
                max_tokens=2048,
            )
            
            # Handle potential list/dict responses
            def format_field(value):
                if isinstance(value, list):
                    return "\n".join(f"- {item}" for item in value)
                elif isinstance(value, dict):
                    return "\n".join(f"- **{k}**: {v}" for k, v in value.items())
                return str(value)
            
            return TradingReport(
                title=f"Stock Perfect Model - Daily Report ({datetime.now().strftime('%Y-%m-%d')})",
                executive_summary=format_field(result.get("executive_summary", "")),
                market_regime_analysis=format_field(result.get("market_regime_analysis", "")),
                top_opportunities=format_field(result.get("top_opportunities", "")),
                risk_warnings=format_field(result.get("risk_warnings", "")),
                recommended_positions=format_field(result.get("recommended_positions", "")),
                timestamp=datetime.now(),
            )
            
        except Exception as e:
            return TradingReport(
                title=f"Stock Perfect Model - Daily Report ({datetime.now().strftime('%Y-%m-%d')})",
                executive_summary=f"Report generation failed: {str(e)}",
                market_regime_analysis="Unable to analyze regime.",
                top_opportunities="Manual review required.",
                risk_warnings="System error - exercise caution.",
                recommended_positions="No automated recommendations available.",
                timestamp=datetime.now(),
            )
    
    def generate_alert(
        self,
        alert_type: str,
        ticker: str,
        signal_strength: float,
        context: str,
    ) -> str:
        """
        Generate a quick alert message for significant signals.
        
        Args:
            alert_type: Type of alert (e.g., "RESIDUAL_SPIKE", "REGIME_CHANGE")
            ticker: Relevant ticker (or "MARKET" for market-wide)
            signal_strength: Strength of the signal (-1 to 1 or other scale)
            context: Additional context about the signal
            
        Returns:
            Formatted alert string
        """
        prompt = f"""Generate a brief trading alert (2-3 sentences) for:

Alert Type: {alert_type}
Ticker: {ticker}
Signal Strength: {signal_strength}
Context: {context}

Be concise and actionable. Include recommended action."""

        try:
            return self.client.invoke(
                prompt=prompt,
                model=ClaudeModel.HAIKU,  # Use Haiku for quick alerts
                max_tokens=256,
            )
        except Exception as e:
            return f"[{alert_type}] {ticker}: Signal {signal_strength:.2f} - {context}"


def generate_report(
    h1_total: float,
    h1_max: float,
    h1_count: int,
    regime: str,
    risk: str,
    residuals_df: pd.DataFrame,
    **kwargs
) -> TradingReport:
    """Convenience function for quick report generation."""
    generator = ReportGenerator()
    return generator.generate_daily_report(
        h1_total_persistence=h1_total,
        h1_max_persistence=h1_max,
        h1_feature_count=h1_count,
        regime_type=regime,
        risk_level=risk,
        top_residuals=residuals_df,
        **kwargs
    )


if __name__ == "__main__":
    # Test the report generator
    print("Testing Report Generator...")
    
    generator = ReportGenerator()
    
    # Create sample data
    residuals_df = pd.DataFrame({
        "ticker": ["NVDA", "TSLA", "AAPL", "AMD", "META"],
        "residual": [0.08, -0.06, 0.04, -0.03, 0.02],
        "sector": ["Tech", "Auto", "Tech", "Tech", "Tech"],
    })
    
    sentiment_df = pd.DataFrame({
        "ticker": ["NVDA", "TSLA"],
        "sentiment_score": [0.7, -0.3],
        "summary": ["Strong AI demand outlook", "Delivery concerns persist"],
    })
    
    print("\nGenerating daily report...")
    report = generator.generate_daily_report(
        h1_total_persistence=1.8,
        h1_max_persistence=0.6,
        h1_feature_count=8,
        regime_type="Sector-Rotation",
        risk_level="Medium",
        top_residuals=residuals_df,
        sentiment_data=sentiment_df,
    )
    
    print("\n" + "="*60)
    print(report.to_markdown())
    
    # Save HTML version
    with open("sample_report.html", "w") as f:
        f.write(report.to_html())
    print("\nHTML report saved to sample_report.html")

